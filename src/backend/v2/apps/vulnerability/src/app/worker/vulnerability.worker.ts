import {
  CloudEvent,
  MessagePubSubService,
} from '@firewall-backend/message-pub-sub';
import { Injectable, OnModuleInit } from '@nestjs/common';
import { InjectPinoLogger, PinoLogger } from 'nestjs-pino';
import { VulnerabilityService } from '../vulnerability/vulnerability.service';
import * as UUID from 'uuid';
import { AssetEventData } from '@firewall-backend/dto';
import { ConfigurationService } from '@firewall-backend/configuration';
import {
  DEFAULT_CONFIG_UUID,
  DEFAULT_DAST_CONFIG_UUID,
  DEFAULT_TECH_CONFIG_UUID,
} from '@firewall-backend/constants';
import {
  AssetType,
  IncidentClosedBy,
  ScanStatus,
  VulnerabilityProfiles,
} from '@firewall-backend/enums';
import { VulnerabilityRescanEventData } from '../vulnerability/dto/vulnerability-retest.dto';
import { IncidentService } from '../incident/incident.service';
import { TechDetectionService } from '../tech-detect/tech-detection.service';
import { VulnerabilityScan } from '@firewall-backend/entities';
import path from 'path';
import { NucleiUtils } from './fork-utils/nuclei.utils';
import { NucleiInfo } from './interface';

@Injectable()
export class VulnerabilityWorker implements OnModuleInit {
  constructor(
    private readonly pubSubService: MessagePubSubService,
    private readonly vulnerabilityService: VulnerabilityService,
    @InjectPinoLogger(VulnerabilityWorker.name)
    private readonly logger: PinoLogger,
    private readonly configurationService: ConfigurationService,
    private readonly incidentService: IncidentService,
    private readonly techDetectionService: TechDetectionService
  ) {}

  async onModuleInit() {
    this.logger.info({}, 'Initializing VulnerabilityWorker');
    try {
      await Promise.all([
        this.pubSubService.receiveMessage(
          {
            topics: Object.values(AssetType).flatMap((type) => [
              `asset.${type}.added`,
              `asset.${type}.updated`,
            ]),
            exchangeName: 'vulnerability-exchange',
            queueName: 'vulnerability-queue',
          },
          this.handleMessage.bind(this)
        ),
        this.pubSubService.receiveMessage(
          {
            topics: ['vulnerability.rescan'],
            exchangeName: 'vulnerability-exchange',
            queueName: 'vulnerability-rescan-queue',
          },
          this.handleRescan.bind(this)
        ),
      ]);
      this.logger.info('VulnerabilityWorker is now listening for messages');
    } catch (err) {
      this.logger.error({ err }, 'Error initializing VulnerabilityWorker');
    }
  }

  sleep = (ms: number): Promise<void> => {
    return new Promise((resolve) => setTimeout(resolve, ms));
  };

  private async handleMessage(msg: CloudEvent<AssetEventData>) {
    this.logger.info({ data: msg }, 'Received asset message');
    const startTime = Date.now();
    const {
      assetName,
      assetType,
      assetId,
      scanType,
      scanCreatedBy,
      scheduleRunId,
    } = msg.data;
    let {
      profiles,
      configurationId,
      dastConfigurationId,
      techConfigurationId,
    } = msg.data;
    if (!profiles) {
      profiles = Object.values(
        VulnerabilityProfiles
      ) as VulnerabilityProfiles[];
    }
    if (!configurationId) configurationId = DEFAULT_CONFIG_UUID;
    const configuration = await this.configurationService.findOne(
      configurationId
    );

    if (!dastConfigurationId) dastConfigurationId = DEFAULT_DAST_CONFIG_UUID;
    const dastConfiguration = await this.configurationService.findOne(
      dastConfigurationId
    );

    if (!techConfigurationId) techConfigurationId = DEFAULT_TECH_CONFIG_UUID;
    const techConfiguration = await this.configurationService.findOne(
      techConfigurationId
    );

    let newScan: VulnerabilityScan;
    try {
      newScan = await this.vulnerabilityService.createScan(
        scanType,
        assetId,
        scanCreatedBy,
        scheduleRunId
      );

      await this.vulnerabilityService.updateScanStatus(
        newScan.uuid,
        ScanStatus.IN_PROGRESS
      );

      const nucleiUtils = new NucleiUtils(this.logger);

      const scanPromises = profiles.map(async (profile) => {
        const profileStartTime = Date.now();

        let configJson = configuration.config;
        if (profile == VulnerabilityProfiles.DAST)
          configJson = dastConfiguration.config;
        if (profile == VulnerabilityProfiles.TECH_DETECT)
          configJson = techConfiguration.config;

        const results = await nucleiUtils.runNucleiWorker({
          assets: [assetName],
          profileName: profile,
          configJson,
          profilesDir: path.join(
            process.env.VULNERABILITY_PATH || `${process.cwd()}`,
            'firewall-data',
            'profiles'
          ),
        });

        const profileEndTime = Date.now();
        const profileDuration = profileEndTime - profileStartTime;

        this.logger.info(
          {
            assetName,
            profile,
            resultsCount: results.length,
            durationMs: profileDuration,
          },
          'Nuclei scan completed for profile'
        );

        // Save results concurrently
        const saveResultsPromises = results.map((result) => {
          if (result) {
            return profile === VulnerabilityProfiles.TECH_DETECT
              ? this.techDetectionService.create(
                  result,
                  assetName,
                  assetType,
                  assetId,
                  configuration,
                  newScan
                )
              : this.vulnerabilityService.saveVulnerability(
                  result,
                  profile,
                  assetName,
                  assetType,
                  assetId,
                  configuration,
                  newScan
                );
          } else {
            return Promise.resolve();
          }
        });

        return Promise.all(saveResultsPromises);
      });
      await Promise.all(scanPromises);

      await this.vulnerabilityService.updateScanStatus(
        newScan.uuid,
        ScanStatus.COMPLETED
      );

      const endTime = Date.now();
      const totalDuration = endTime - startTime;

      this.logger.info(
        {
          assetName,
          totalProfiles: profiles.length,
          totalDurationMs: totalDuration,
        },
        'Total scan completed for asset'
      );
    } catch (error) {
      console.log(error);
      this.logger.error({ error, assetName }, 'Error processing asset message');

      // If something failed, update the scan to FAILED/ERROR if we created it
      if (newScan) {
        await this.vulnerabilityService.updateScanStatus(
          newScan.uuid,
          ScanStatus.FAILED,
          error.message
        );
      }
    }
  }

  private async handleRescan(msg: CloudEvent<VulnerabilityRescanEventData>) {
    const {
      vulnerabilityId,
      assetName,
      templateId,
      profile,
      configJson,
      originalVulnerabilityInfo,
    } = msg.data;

    try {
      this.logger.info({ data: msg }, 'Starting vulnerability rescan');

      const nucleiUtils = new NucleiUtils(this.logger);

      // Run nuclei scan with specific template
      const results = await nucleiUtils.runNucleiWorker({
        assets: [assetName],
        profileName: profile,
        configJson,
        templateId,
        profilesDir: process.env.VULNERABILITY_PATH || 'firewall-data/profiles',
      });

      console.log(
        results.map((r) => {
          const originalInfo = originalVulnerabilityInfo?.info ?? {};
          const currentInfo = r?.info ?? ({} as NucleiInfo);

          return {
            templateId: r?.['template-id'],
            isSame:
              r?.['template-id'] ===
                originalVulnerabilityInfo?.['template-id'] &&
              currentInfo.name === originalInfo.name &&
              currentInfo.severity === originalInfo.severity &&
              currentInfo.description === originalInfo.description &&
              currentInfo.impact === originalInfo.impact &&
              currentInfo.remediation === originalInfo.remediation,
          };
        })
      );

      // Check if the vulnerability still exists
      const vulnerabilityStillExists = results.some((result) => {
        const originalInfo = originalVulnerabilityInfo?.info ?? {};
        const currentInfo = result?.info ?? ({} as NucleiInfo);
        return (
          result?.['template-id'] ===
            originalVulnerabilityInfo?.['template-id'] &&
          currentInfo.name === originalInfo.name &&
          currentInfo.severity === originalInfo.severity &&
          currentInfo.description === originalInfo.description &&
          currentInfo.impact === originalInfo.impact &&
          currentInfo.remediation === originalInfo.remediation
        );
      });

      if (!vulnerabilityStillExists) {
        // Close the incident associated with the vulnerability
        await this.incidentService.closeIncident(
          vulnerabilityId,
          'Vulnerability not detected in retest',
          1,
          IncidentClosedBy.PROGRAM
        );

        this.logger.info(
          { vulnerabilityId, assetName },
          'Incident closed after retest - vulnerability no longer detected'
        );
      } else {
        this.logger.info(
          { vulnerabilityId, assetName },
          'Vulnerability still exists after retest'
        );
      }
    } catch (error) {
      console.log(error);
      this.logger.error(
        { error, vulnerabilityId, assetName },
        'Error processing vulnerability rescan'
      );
      throw error;
    }
  }

  async pushToQueue(body: AssetEventData) {
    const { assetName, assetType } = body;
    try {
      const message: CloudEvent<AssetEventData> = {
        data: body,
        id: UUID.v4(),
        source: 'api',
        specversion: '1.0',
        time: new Date(),
        type: `asset.${assetType}.added`,
      };

      await this.pubSubService.sendMessage<AssetEventData>(
        message.type,
        message
      );
      this.logger.info(
        { assetName, assetType, messageId: message.id },
        'Message pushed to queue'
      );
    } catch (error) {
      this.logger.error(
        { error, assetName, assetType },
        'Error pushing message to queue'
      );
      throw new Error('Failed to push message to queue');
    }
  }
}
