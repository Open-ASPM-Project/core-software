const { spawnSync } = require('child_process');
const fs = require('fs');
const os = require('os');
const path = require('path');
const crypto = require('crypto');
const yaml = require('js-yaml');

console.log('[NucleiWorker] Worker started');

process.on('message', async (message) => {
  console.log('[NucleiWorker] Received message from parent process');
  let tempFile = null;
  let tempConfigFile = null;
  let tempOutputFile = null;

  try {
    if (!message || !message.assets) {
      console.error('[NucleiWorker] No assets received');
      throw new Error('No assets received');
    }

    const {
      assets,
      profileName,
      templateId,
      configJson,
      profilesDir = path.join(process.cwd(), 'firewall-data', 'profiles'),
      nucleiBinary = 'nuclei',
      requestId = crypto.randomUUID().substring(0, 8),
    } = message;

    console.log(`[NucleiWorker] [${requestId}] Processing nuclei scan request`);

    // Write asset URLs to a temp file
    tempFile = path.join(os.tmpdir(), `nuclei-assets-${requestId}.txt`);
    fs.writeFileSync(tempFile, assets.join('\n'), 'utf8');
    console.log(
      `[NucleiWorker] [${requestId}] Created temp file at ${tempFile}`
    );

    tempConfigFile = path.join(os.tmpdir(), `nuclei-config-${requestId}.yml`);
    fs.writeFileSync(tempConfigFile, yaml.dump(configJson), 'utf-8');
    console.log(
      `[NucleiWorker] [${requestId}] Created temp config file at ${tempConfigFile}`
    );

    // Prepare output file name
    tempOutputFile = path.join(os.tmpdir(), `nuclei-output-${requestId}.txt`);

    // Build nuclei command
    const args = [
      '-l',
      tempFile,
      '-jle',
      tempOutputFile,
      '-config',
      tempConfigFile,
      '-sc',
      '-headless',
      '-debug',
      '-silent',
    ];

    // Add either profile or template flag
    if (templateId) {
      args.push('-t', templateId);
    } else if (profileName) {
      const profilePath = path.join(profilesDir, `${profileName}.yml`);
      args.push('--profile', profilePath);
    } else {
      throw new Error('Either profileName or templateId must be provided');
    }

    console.log(
      `[NucleiWorker] [${requestId}] Executing nuclei: nuclei ${args.join(' ')}`
    );
    const startTime = Date.now();

    const result = spawnSync(nucleiBinary, args, { encoding: 'utf8' });

    const executionTime = (Date.now() - startTime) / 1000;
    console.log(
      `[NucleiWorker] [${requestId}] Command completed in ${executionTime.toFixed(
        2
      )}s`
    );

    // Clean up temp file
    if (fs.existsSync(tempFile)) {
      fs.unlinkSync(tempFile);
      console.log(`[NucleiWorker] [${requestId}] Removed temp file`);
    }

    // Clean up temp config file
    if (fs.existsSync(tempConfigFile)) {
      fs.unlinkSync(tempConfigFile);
      console.log(`[NucleiWorker] [${requestId}] Removed temp config file`);
    }

    // Check for errors
    if (result.error) {
      console.error(
        `[NucleiWorker] [${requestId}] Error: ${result.error.message}`
      );
      throw new Error(`Error executing nuclei: ${result.error.message}`);
    }
    if (result.status !== 0) {
      console.error(
        `[NucleiWorker] [${requestId}] nuclei exited with status ${result.status}`
      );
      console.error(`[NucleiWorker] [${requestId}] stderr: ${result.stderr}`);
      throw new Error(
        `nuclei exited with status ${result.status}: ${result.stderr}`
      );
    }

    // Read results
    let findings = [];
    if (fs.existsSync(tempOutputFile)) {
      const content = fs.readFileSync(tempOutputFile, 'utf8');
      findings = content
        .split('\n')
        .filter(Boolean)
        .flatMap((line) => {
          try {
            return JSON.parse(line);
          } catch {
            return null;
          }
        })
        .filter(Boolean);
    } else {
      console.error(
        `[NucleiWorker] [${requestId}] output file does not exists`
      );
    }

    // Clean up temp output file
    if (fs.existsSync(tempOutputFile)) {
      fs.unlinkSync(tempOutputFile);
      console.log(`[NucleiWorker] [${requestId}] Removed temp output file`);
    }

    // Send result back
    process.send({
      status: 'success',
      metadata: {
        executionTime,
        requestId,
        findingsCount: findings.length,
      },
      findings,
    });

    console.log(`[NucleiWorker] [${requestId}] Request processing complete`);
  } catch (error) {
    const requestId = message?.requestId || 'unknown';

    console.error(`[NucleiWorker] [${requestId}] Error in worker:`, error);
    if (tempFile && fs.existsSync(tempFile)) {
      fs.unlinkSync(tempFile);
      console.log(
        `[NucleiWorker] [${requestId}] Removed temp file after error`
      );
    }

    process.send({
      status: 'error',
      error: {
        message: error.message,
        stack: error.stack,
        type: error.name,
      },
      requestId,
    });

    console.log(
      `[NucleiWorker] [${requestId}] Error notification sent to parent`
    );
  }
});

// Handle process termination
process.on('SIGTERM', () => {
  console.log('[NucleiWorker] Received SIGTERM. Shutting down.');
  process.exit(0);
});
process.on('SIGINT', () => {
  console.log('[NucleiWorker] Received SIGINT. Shutting down.');
  process.exit(0);
});
process.on('disconnect', () => {
  console.log('[NucleiWorker] Disconnected from parent. Exiting.');
  process.exit(1);
});

// Notify parent that worker is ready
console.log('[NucleiWorker] Worker initialized and ready');
process.send({ status: 'ready' });
