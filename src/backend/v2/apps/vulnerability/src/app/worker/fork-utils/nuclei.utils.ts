import { fork, ChildProcess } from 'child_process';
import * as path from 'path';
import { PinoLogger } from 'nestjs-pino';
import { BadRequestException } from '@nestjs/common';
import * as crypto from 'crypto';
import { NucleiScanResult } from '../interface';

export interface NucleiScanOptions {
  assets: string[];
  profileName?: string;
  templateId?: string;
  configJson: Record<string, any>;
  profilesDir?: string;
  nucleiBinary?: string;
}

export class NucleiUtils {
  private readonly logger: PinoLogger;

  constructor(logger: PinoLogger) {
    this.logger = logger;
  }

  /**
   * Run nuclei worker to scan assets and return findings
   */
  async runNucleiWorker(
    options: NucleiScanOptions
  ): Promise<NucleiScanResult[]> {
    const {
      assets,
      profileName,
      templateId,
      configJson,
      profilesDir,
      nucleiBinary,
    } = options;

    if (!assets || assets.length === 0) {
      throw new BadRequestException('No assets provided for nuclei scan');
    }
    if (!profileName && !templateId) {
      throw new BadRequestException(
        'Either profileName or templateId must be provided'
      );
    }

    const startTime = Date.now();
    const requestId = crypto.randomUUID().substring(0, 8);

    // Path to the nuclei worker script
    const workerScriptPath = path.join(__dirname, 'forks', 'nuclei.worker.js');

    // Prepare the data to send to the worker
    const workerData: any = {
      assets,
      profileName,
      configJson,
      profilesDir,
      nucleiBinary,
      requestId,
    };
    if (templateId) {
      workerData.templateId = templateId;
    }

    return new Promise<any[]>((resolve, reject) => {
      let child: ChildProcess | null = null;

      try {
        child = fork(workerScriptPath, []);

        this.logger.debug(
          { pid: child.pid, requestId },
          `Forked nuclei worker process`
        );

        let resultReceived = false;

        child.on('message', (message: any) => {
          resultReceived = true;
          const duration = (Date.now() - startTime) / 1000;

          this.logger.debug(
            {
              status: message?.status,
              duration,
              requestId,
            },
            `Received message from nuclei worker`
          );

          if (message?.status === 'success') {
            this.logger.info(
              {
                duration,
                requestId,
                findingsCount: message.metadata?.findingsCount,
              },
              `Nuclei scan completed successfully`
            );
            resolve(message.findings ?? []);
          } else if (message?.status === 'error') {
            const error = new Error(
              message.error?.message ?? `Unknown nuclei worker error`
            );
            error.stack = message.error?.stack;
            this.logger.error(
              {
                error: error.message,
                stack: error.stack,
                duration,
                requestId,
              },
              `Nuclei worker reported an error`
            );
            reject(new Error(`Nuclei scan failed: ${error.message}`));
          } else if (message?.status === 'ready') {
            this.logger.debug(
              { requestId },
              `Nuclei worker ready, sending assets`
            );
            child?.send(workerData);
          } else {
            this.logger.warn(
              {
                message,
                duration,
                requestId,
              },
              `Received unexpected message from nuclei worker`
            );
            reject(new Error(`Received unexpected message from nuclei worker`));
          }

          // Kill the worker if we have a final result
          if (
            (message?.status === 'success' || message?.status === 'error') &&
            child &&
            !child.killed
          ) {
            child.kill();
          }
        });

        child.on('error', (error) => {
          if (resultReceived) return;

          const duration = (Date.now() - startTime) / 1000;
          this.logger.error(
            {
              error: error.message,
              duration,
              requestId,
            },
            `Nuclei worker process error event`
          );

          reject(new Error(`Nuclei worker process error: ${error.message}`));
        });

        child.on('exit', (code, signal) => {
          if (resultReceived) return;

          const duration = (Date.now() - startTime) / 1000;
          this.logger.warn(
            {
              code,
              signal,
              duration,
              requestId,
            },
            `Nuclei worker process exited prematurely`
          );

          reject(
            new Error(
              `Nuclei worker process exited prematurely with code ${code}, signal ${signal}`
            )
          );
        });
      } catch (forkError) {
        const duration = (Date.now() - startTime) / 1000;

        this.logger.error(
          {
            error: forkError.message,
            duration,
            requestId,
          },
          `Failed to fork nuclei worker process`
        );

        reject(new Error(`Failed to fork nuclei worker: ${forkError.message}`));
      }
    });
  }
}
