import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { TechDetection } from './entities/tech-detection.entity';
import { TechDetectionFilterDto } from './dto/tech-detection.dto';
import { PaginationRequestDto } from '@firewall-backend/dto';
import { InjectPinoLogger, PinoLogger } from 'nestjs-pino';
import { AssetType, Severity } from '@firewall-backend/enums';
import { NucleiScanResult } from '../worker/interface';
import { Configuration, VulnerabilityScan } from '@firewall-backend/entities';

@Injectable()
export class TechDetectionService {
  constructor(
    @InjectRepository(TechDetection)
    private techDetectionRepository: Repository<TechDetection>,
    @InjectPinoLogger(TechDetectionService.name)
    private readonly logger: PinoLogger
  ) {}

  private mapSeverity(severity?: string): Severity | null {
    if (!severity) return null;
    const severityMap: Record<string, Severity> = {
      info: Severity.INFO,
      low: Severity.LOW,
      medium: Severity.MEDIUM,
      high: Severity.HIGH,
      critical: Severity.CRITICAL,
    };
    return severityMap[severity.toLowerCase()] || null;
  }

  async create(
    dto: NucleiScanResult,
    assetName: string,
    assetType: AssetType,
    assetId: number,
    configuration: Configuration,
    scan: VulnerabilityScan
  ): Promise<TechDetection> {
    try {
      const entity = new TechDetection();

      // Map basic fields
      entity.templateId = dto['template-id'];
      entity.templatePath = dto['template-path'];
      entity.templateEncoded = dto['template-encoded'];

      // Extract and store important fields from "info"
      if (dto.info) {
        entity.infoName = dto.info.name;
        entity.infoSeverity = this.mapSeverity(dto.info.severity);
        entity.infoDescription = dto.info.description;
        entity.infoImpact = dto.info.impact;
        entity.infoRemediation = dto.info.remediation;
      }

      // Assign standard fields
      entity.type = dto.type || null;
      entity.host = dto.host || null;
      entity.port = dto.port || null;
      entity.scheme = dto.scheme || null;
      entity.url = dto.url || null;
      entity.matchedAt = dto['matched-at'] || null;
      entity.request = dto.request || null;
      entity.response = dto.response || null;
      entity.ip = dto.ip || null;
      entity.timestamp = dto.timestamp ? new Date(dto.timestamp) : null;
      entity.curlCommand = dto['curl-command'] || null;
      entity.matcherStatus = dto['matcher-status'] ?? null;

      // New fields for profiling and asset tracking
      entity.assetName = assetName;
      entity.assetType = assetType;
      entity.assetId = assetId;
      entity.configuration = configuration;
      entity.scan = scan;

      // Store full JSON payload in "allPayload"
      entity.allPayload = JSON.parse(JSON.stringify(dto));

      this.logger.debug({ entity }, 'Prepared entity for insert/update');

      // 1) Check if entity already exists by unique fields
      const existingEntity = await this.techDetectionRepository.findOne({
        where: {
          templateId: entity.templateId,
          host: entity.host,
          assetName: entity.assetName,
        },
      });

      // 2) Update if found, otherwise insert
      let savedEntity;
      if (existingEntity) {
        savedEntity = await this.techDetectionRepository
          .createQueryBuilder()
          .update(TechDetection)
          .set({
            templatePath: entity.templatePath,
            templateEncoded: entity.templateEncoded,
            infoName: entity.infoName,
            infoSeverity: entity.infoSeverity,
            infoDescription: entity.infoDescription,
            infoImpact: entity.infoImpact,
            infoRemediation: entity.infoRemediation,
            type: entity.type,
            url: entity.url,
            matchedAt: entity.matchedAt,
            request: entity.request,
            response: entity.response,
            ip: entity.ip,
            timestamp: entity.timestamp,
            curlCommand: entity.curlCommand,
            matcherStatus: entity.matcherStatus,
            allPayload: entity.allPayload,
            assetName: entity.assetName,
            assetType: entity.assetType,
          })
          .where('id = :id', { id: existingEntity.id })
          .returning('*')
          .execute();
      } else {
        savedEntity = await this.techDetectionRepository
          .createQueryBuilder()
          .insert()
          .into(TechDetection)
          .values(entity)
          .returning('*')
          .execute();
      }

      // Extract the saved/updated row from the query result
      const savedData = savedEntity.raw[0];

      this.logger.info(
        { id: savedData?.id, assetName, assetType },
        'Scan result saved successfully'
      );

      return savedData;
    } catch (error) {
      this.logger.error(
        { error: error.message, stack: error.stack, assetName, assetType },
        'Error saving scan result'
      );
      throw new Error('Failed to save scan result');
    }
  }

  async findAll(
    filters: TechDetectionFilterDto,
    pagination: PaginationRequestDto
  ): Promise<[TechDetection[], number]> {
    try {
      const query =
        this.techDetectionRepository.createQueryBuilder('tech_detection');

      if (filters.assetId) {
        query.andWhere('tech_detection.assetId = :assetId', {
          assetId: filters.assetId,
        });
      }

      if (filters.assetName) {
        query.andWhere('tech_detection.assetName ILIKE :assetName', {
          assetName: `%${filters.assetName}%`,
        });
      }

      if (filters.assetType) {
        query.andWhere('tech_detection.assetType = :assetType', {
          assetType: filters.assetType,
        });
      }

      if (filters.name) {
        query.andWhere('tech_detection.name ILIKE :name', {
          name: `%${filters.name}%`,
        });
      }

      if (filters.tags && filters.tags.length > 0) {
        query.andWhere('tech_detection.tags && :tags', { tags: filters.tags });
      }

      const page = pagination.page || 1;
      const limit = pagination.limit || 10;

      query
        .skip((page - 1) * limit)
        .take(limit)
        .orderBy('tech_detection.createdAt', 'DESC');

      return await query.getManyAndCount();
    } catch (error) {
      this.logger.error({ error }, 'Error finding tech detections');
      throw error;
    }
  }

  async findOne(uuid: string): Promise<TechDetection> {
    try {
      const techDetection = await this.techDetectionRepository.findOne({
        where: { uuid },
      });

      if (!techDetection) {
        throw new NotFoundException(
          `Tech detection with UUID "${uuid}" not found`
        );
      }

      return techDetection;
    } catch (error) {
      this.logger.error({ error }, 'Error finding tech detection');
      throw error;
    }
  }
}
