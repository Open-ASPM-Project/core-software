import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { ArrayContains, Repository } from 'typeorm';
import { AssetAllowlist } from './entities/asset-allowlist.entity';
import {
  CreateAssetAllowlistDto,
  UpdateAssetAllowlistDto,
} from './dtos/asset-allowlist.dto';
import { AssetType, VulnerabilityProfiles } from '@firewall-backend/enums';
import { Asset } from '@firewall-backend/entities';
import { InjectPinoLogger, PinoLogger } from 'nestjs-pino';

@Injectable()
export class AssetAllowlistService {
  constructor(
    @InjectRepository(Asset)
    private readonly assetRepository: Repository<Asset>,
    @InjectRepository(AssetAllowlist)
    private readonly assetAllowlistRepository: Repository<AssetAllowlist>,
    @InjectPinoLogger(AssetAllowlistService.name)
    private readonly logger: PinoLogger
  ) {}

  async create(
    createAssetAllowlistDto: CreateAssetAllowlistDto
  ): Promise<AssetAllowlist> {
    const asset = await this.assetRepository.findOne({
      where: {
        uuid: createAssetAllowlistDto.assetId,
      },
    });
    if (!asset) {
      this.logger.error({ createAssetAllowlistDto }, 'Asset not found');
      throw new NotFoundException('Asset not found');
    }

    const assetAllowlist = this.assetAllowlistRepository.create({
      active: createAssetAllowlistDto.active,
      assetId: asset.id,
      assetType: asset.type,
      description: createAssetAllowlistDto.description,
      vulnerabilityProfiles: createAssetAllowlistDto.vulnerabilityProfiles,
    });
    return await this.assetAllowlistRepository.save(assetAllowlist);
  }

  async findAll(): Promise<AssetAllowlist[]> {
    return this.assetAllowlistRepository.find();
  }

  async findOne(id: string): Promise<AssetAllowlist> {
    return this.assetAllowlistRepository.findOne({ where: { id } });
  }

  async update(
    id: string,
    updateAssetAllowlistDto: UpdateAssetAllowlistDto
  ): Promise<AssetAllowlist> {
    await this.assetAllowlistRepository.update(id, updateAssetAllowlistDto);
    return this.findOne(id);
  }

  async remove(id: string): Promise<void> {
    await this.assetAllowlistRepository.delete(id);
  }

  async isAssetAllowed(
    assetType: AssetType,
    assetId: string,
    profile?: string
  ): Promise<boolean> {
    const asset = await this.assetRepository.findOne({
      where: {
        uuid: assetId,
      },
    });
    if (!asset) {
      this.logger.error({ assetId }, 'Asset not found');
      throw new NotFoundException('Asset not found');
    }

    const query = {
      where: {
        assetType,
        assetId: asset.id,
        active: true,
      },
    };

    if (profile) {
      query.where['vulnerability_profiles'] = profile;
    }

    const allowlist = await this.assetAllowlistRepository.findOne(query);
    return !!allowlist;
  }

  async findByProfile(
    profile: VulnerabilityProfiles
  ): Promise<AssetAllowlist[]> {
    return this.assetAllowlistRepository.find({
      where: {
        vulnerabilityProfiles: ArrayContains([profile]),
        active: true,
      },
    });
  }

  async isAssetWhitelisted(
    assetId: string,
    profile: VulnerabilityProfiles
  ): Promise<boolean> {
    const asset = await this.assetRepository.findOne({
      where: {
        uuid: assetId,
      },
    });
    if (!asset) {
      this.logger.error({ assetId }, 'Asset not found');
      throw new NotFoundException('Asset not found');
    }

    const allowlist = await this.assetAllowlistRepository.findOne({
      where: {
        assetId: asset.id,
        vulnerabilityProfiles: ArrayContains([profile]),
        active: true,
      },
    });
    return !!allowlist;
  }
}
