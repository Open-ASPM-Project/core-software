import { Injectable } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { exec } from 'child_process';
import { promisify } from 'util';
import { InjectPinoLogger, PinoLogger } from 'nestjs-pino';
import { existsSync } from 'fs';
import { VulnerabilityService } from './vulnerability.service';
import {
  CloudEvent,
  MessagePubSubService,
} from '@firewall-backend/message-pub-sub';
import * as UUID from 'uuid';
import { ScanTriggerType } from '@firewall-backend/enums';
import * as crypto from 'crypto';
import { AssetEventData } from '@firewall-backend/dto';

const asyncExec = promisify(exec);

@Injectable()
export class VulnerabilityTemplatesCronService {
  private readonly repoLocalPath =
    process.env.VULNERABILITY_PATH || 'firewall-data' + '/nuclei-templates';
  private readonly remote = 'origin';
  private readonly branch = 'master';

  constructor(
    @InjectPinoLogger(VulnerabilityTemplatesCronService.name)
    private readonly logger: PinoLogger,
    private readonly vulnerabilityService: VulnerabilityService,
    private readonly pubSubService: MessagePubSubService
  ) {}

  /**
   * Runs every 2 hours. Adjust the CronExpression or provide a custom cron string.
   */
  @Cron(CronExpression.EVERY_2_HOURS, { name: crypto.randomUUID() })
  async checkForRepoUpdates(): Promise<void> {
    try {
      this.logger.info('Checking nuclei-templates repo for updates...');

      // (Optional) If not already cloned manually, you could do so here:
      //
      if (!existsSync(this.repoLocalPath)) {
        this.logger.info('Local repo not found. Cloning...');
        await asyncExec(
          `git clone https://github.com/projectdiscovery/nuclei-templates.git ${this.repoLocalPath}`
        );
      }

      // 1) Fetch new commits from remote
      await asyncExec(
        `cd ${this.repoLocalPath} && git fetch ${this.remote} ${this.branch}`
      );

      // 2) Check if there are any new commits
      const { stdout } = await asyncExec(
        `cd ${this.repoLocalPath} && git rev-list HEAD...${this.remote}/${this.branch} --count`
      );
      const commitCount = parseInt(stdout.trim(), 10);

      if (commitCount > 0) {
        this.logger.info(
          `Found ${commitCount} new commits in nuclei-templates; pulling...`
        );
        await asyncExec(
          `cd ${this.repoLocalPath} && git pull ${this.remote} ${this.branch}`
        );
        this.logger.info('Nuclei templates updated successfully.');

        // Re-run scans for all assets, or whichever logic you prefer
        this.logger.info('Triggering re-scan for all assets...');
        await this.reScanAllAssets();
      } else {
        this.logger.info('No new commits in nuclei-templates repo.');
      }
    } catch (error) {
      this.logger.error({ error }, 'Error checking or pulling repo updates.');
    }
  }

  public async reScanAllAssets(): Promise<void> {
    try {
      // Example: fetch all assets from DB. Adjust according to how you store assets.
      const allAssets = await this.vulnerabilityService.getAllAssets();

      // For each asset, enqueue a message to scan it again
      for (const asset of allAssets) {
        const message: CloudEvent<AssetEventData> = {
          data: {
            assetName: asset.assetName,
            assetType: asset.assetType,
            assetId: asset.assetId,
            configurationId: asset.configuration_id,
            scanType: ScanTriggerType.LIVE_SCAN_NUCLEI_TEMPLATE_CHANGE,
          },
          id: UUID.v4(),
          source: 'auto-rescan',
          specversion: '1.0',
          time: new Date(),
          type: `asset.${asset.assetType}.added`,
        };

        await this.pubSubService.sendMessage<AssetEventData>(
          message.type,
          message
        );
      }
    } catch (error) {
      this.logger.error({ error }, 'Error re-scanning all assets');
    }
  }
}
