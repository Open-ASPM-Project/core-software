import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { InjectPinoLogger, PinoLogger } from 'nestjs-pino';
import { NucleiScanResult } from '../worker/interface';
import { GetVulnerabilityFilterDto, OrderBy } from './dto/vulnerability.dto';
import { IncidentService } from '../incident/incident.service';
import { UniqueVulnerabilityResponse } from './dto/unique-vulnerability.dto';
import { PaginationRequestDto } from '@firewall-backend/dto';
import {
  MessagePubSubService,
  CloudEvent,
} from '@firewall-backend/message-pub-sub';
import { VulnerabilityRescanEventData } from './dto/vulnerability-retest.dto';
import * as UUID from 'uuid';
import {
  AssetType,
  ScanStatus,
  ScanTriggerType,
  Severity,
  VulnerabilityProfiles,
} from '@firewall-backend/enums';
import { Vulnerability, VulnerabilityScan } from '@firewall-backend/entities';
import {
  ConfigurationService,
  Configuration,
} from '@firewall-backend/configuration';

@Injectable()
export class VulnerabilityService {
  constructor(
    @InjectPinoLogger(VulnerabilityService.name)
    private readonly logger: PinoLogger,
    @InjectRepository(Vulnerability)
    private readonly vulnerabilityRepository: Repository<Vulnerability>,
    @InjectRepository(VulnerabilityScan)
    private readonly scanRepository: Repository<VulnerabilityScan>,
    private readonly incidentService: IncidentService,
    private readonly messagePubSubService: MessagePubSubService,
    private readonly configurationService: ConfigurationService
  ) {}

  // Vulnerability
  async saveVulnerability(
    dto: NucleiScanResult,
    profile: VulnerabilityProfiles,
    assetName: string,
    assetType: AssetType,
    assetId: number,
    configuration: Configuration,
    scan: VulnerabilityScan
  ): Promise<Vulnerability> {
    // this.logger.info(
    //   { assetName, assetType, profile, dto: JSON.stringify(dto).slice(0, 200) },
    //   'Received scan result'
    // );

    try {
      const entity = new Vulnerability();

      // Map basic fields
      entity.templateId = dto['template-id'];
      entity.templatePath = dto['template-path'];
      entity.templateEncoded = dto['template-encoded'];

      // Extract and store important fields from "info"
      if (dto.info) {
        entity.infoName = dto.info.name;
        entity.infoSeverity = this.mapSeverity(dto.info.severity);
        entity.infoDescription = dto.info.description;
        entity.infoImpact = dto.info.impact;
        entity.infoRemediation = dto.info.remediation;
      }

      // Assign standard fields
      entity.type = dto.type || null;
      entity.host = dto.host || null;
      entity.port = dto.port || null;
      entity.scheme = dto.scheme || null;
      entity.url = dto.url || null;
      entity.matchedAt = dto['matched-at'] || null;
      entity.request = dto.request || null;
      entity.response = dto.response || null;
      entity.ip = dto.ip || null;
      entity.timestamp = dto.timestamp ? new Date(dto.timestamp) : null;
      entity.curlCommand = dto['curl-command'] || null;
      entity.matcherStatus = dto['matcher-status'] ?? null;

      // New fields for profiling and asset tracking
      entity.profile = profile;
      entity.assetName = assetName;
      entity.assetType = assetType;
      entity.assetId = assetId;
      entity.configuration = configuration;
      entity.scan = scan;

      // Store full JSON payload in "allPayload"
      entity.allPayload = JSON.parse(JSON.stringify(dto));

      this.logger.debug({ entity }, 'Prepared entity for insert/update');

      // 1) Check if entity already exists by unique fields
      const existingEntity = await this.vulnerabilityRepository.findOne({
        where: {
          templateId: entity.templateId,
          host: entity.host,
          profile: entity.profile,
          assetName: entity.assetName,
        },
      });

      // 2) Update if found, otherwise insert
      let savedEntity;
      if (existingEntity) {
        savedEntity = await this.vulnerabilityRepository
          .createQueryBuilder()
          .update(Vulnerability)
          .set({
            templatePath: entity.templatePath,
            templateEncoded: entity.templateEncoded,
            infoName: entity.infoName,
            infoSeverity: entity.infoSeverity,
            infoDescription: entity.infoDescription,
            infoImpact: entity.infoImpact,
            infoRemediation: entity.infoRemediation,
            type: entity.type,
            url: entity.url,
            matchedAt: entity.matchedAt,
            request: entity.request,
            response: entity.response,
            ip: entity.ip,
            timestamp: entity.timestamp,
            curlCommand: entity.curlCommand,
            matcherStatus: entity.matcherStatus,
            allPayload: entity.allPayload,
            profile: entity.profile,
            assetName: entity.assetName,
            assetType: entity.assetType,
          })
          .where('id = :id', { id: existingEntity.id })
          .returning('*')
          .execute();
      } else {
        savedEntity = await this.vulnerabilityRepository
          .createQueryBuilder()
          .insert()
          .into(Vulnerability)
          .values(entity)
          .returning('*')
          .execute();
      }

      // Extract the saved/updated row from the query result
      const savedData = savedEntity.raw[0];

      // this.logger.info(
      //   { id: savedData?.id, assetName, assetType, profile },
      //   'Scan result saved successfully'
      // );

      // Create incident if this is a new vulnerability
      if (!existingEntity) {
        const incidentName = `${
          savedData.info?.name ?? savedData.templateId
        } - ${savedData.asset?.name ?? 'Unknown Asset'}`;
        await this.incidentService.createForVulnerability(
          savedData.id,
          incidentName,
          savedData.assetId,
          savedData.templateId
        );
      }

      return savedData;
    } catch (error) {
      this.logger.error(
        {
          error: error.message,
          stack: error.stack,
          assetName,
          assetType,
          profile,
        },
        'Error saving scan result'
      );
      throw new Error('Failed to save scan result');
    }
  }

  private mapSeverity(severity?: string): Severity | null {
    if (!severity) return null;
    const severityMap: Record<string, Severity> = {
      info: Severity.INFO,
      low: Severity.LOW,
      medium: Severity.MEDIUM,
      high: Severity.HIGH,
      critical: Severity.CRITICAL,
    };
    return severityMap[severity.toLowerCase()] || null;
  }

  getAvailableFilters() {
    return [
      { key: 'profile', label: 'Profile', type: 'string' },
      { key: 'assetName', label: 'Asset Name', type: 'string' },
      { key: 'assetType', label: 'Asset Type', type: 'string' },
      { key: 'infoSeverity', label: 'Severity', type: 'enum' },
      { key: 'host', label: 'Host', type: 'string' },
      { key: 'ip', label: 'IP Address', type: 'string' },
      { key: 'url', label: 'URL', type: 'string' },
      { key: 'templateId', label: 'Template ID', type: 'string' },
      { key: 'type', label: 'Type', type: 'string' },
      { key: 'port', label: 'Port', type: 'string' },
      { key: 'scheme', label: 'Scheme', type: 'string' },
      { key: 'curlCommand', label: 'Curl Command', type: 'string' },
      { key: 'matcherStatus', label: 'Matcher Status', type: 'boolean' },
      { key: 'timestamp', label: 'Timestamp', type: 'date' },
    ];
  }

  async getDistinctFilterValues(key: string) {
    // Updated: added "timestamp" to the allowedKeys array
    const allowedKeys = [
      'profile',
      'assetName',
      'assetType',
      'infoSeverity',
      'host',
      'ip',
      'url',
      'templateId',
      'type',
      'port',
      'scheme',
      'curlCommand',
      'matcherStatus',
      'timestamp', // <--- ensure it matches getAvailableFilters
    ];

    if (!allowedKeys.includes(key)) {
      throw new Error(`Invalid filter key: ${key}`);
    }

    // If you want to group by "day" or another interval for timestamp fields,
    // you could use date_trunc in Postgres, e.g.:
    // .select(`date_trunc('day', scan.timestamp) AS value, COUNT(*) AS count`)

    const results = await this.vulnerabilityRepository
      .createQueryBuilder('scan')
      .select(`scan.${key} AS value, COUNT(scan.${key}) AS count`)
      .where(`scan.${key} IS NOT NULL`)
      .groupBy(`scan.${key}`)
      .orderBy('count', 'DESC')
      .getRawMany();

    return results;
  }

  async getVulnerability(filters: GetVulnerabilityFilterDto) {
    // Use an alias like 'vuln' for the vulnerability table
    const queryBuilder =
      this.vulnerabilityRepository.createQueryBuilder('vuln');

    // Left-join the vulnerability_scan table so we can show its fields
    queryBuilder.leftJoinAndSelect('vuln.scan', 'scanEntity');

    // -- 1) Apply dynamic filters --
    Object.entries(filters).forEach(([key, value]) => {
      if (
        [
          'page',
          'limit',
          'sort_by',
          'order_by',
          'timestampStart',
          'timestampEnd',
        ].includes(key)
      ) {
        return;
      }

      if (Array.isArray(value)) {
        queryBuilder.andWhere(`vuln.${key} IN (:...${key}Values)`, {
          [`${key}Values`]: value,
        });
      } else if (value !== null && value !== undefined) {
        queryBuilder.andWhere(`vuln.${key} = :${key}Value`, {
          [`${key}Value`]: value,
        });
      }
    });

    // -- 2) Handle timestamp range --
    if (filters.timestampStart) {
      queryBuilder.andWhere('vuln.timestamp >= :start', {
        start: filters.timestampStart,
      });
    }
    if (filters.timestampEnd) {
      queryBuilder.andWhere('vuln.timestamp <= :end', {
        end: filters.timestampEnd,
      });
    }

    // -------------------------------------
    // 3) Sorting
    // -------------------------------------
    if (filters.sort_by) {
      // Only allow sorting by fields that actually exist as columns
      const allowedSortFields = [
        'id',
        'templateId',
        'templatePath',
        'templateEncoded',
        'infoName',
        'infoSeverity',
        'infoDescription',
        'infoImpact',
        'infoRemediation',
        'type',
        'host',
        'port',
        'scheme',
        'url',
        'matchedAt',
        'request',
        'response',
        'ip',
        'timestamp',
        'curlCommand',
        'matcherStatus',
        'profile',
        'assetName',
        'assetType',
        'createdAt',
        'updatedAt',
      ];

      if (!allowedSortFields.includes(filters.sort_by)) {
        throw new Error(`Invalid sorting field: ${filters.sort_by}`);
      }

      const order = filters.order_by == OrderBy.DESC ? 'DESC' : 'ASC';
      queryBuilder.orderBy(`vuln.${filters.sort_by}`, order);
    }

    // -------------------------------------
    // 4) Pagination
    // -------------------------------------
    // Default page=1, limit=10 from the DTO
    const page = filters.page ?? 1;
    const limit = filters.limit ?? 10;
    queryBuilder.skip((page - 1) * limit).take(limit);

    // -------------------------------------
    // 5) Execute query
    // -------------------------------------
    const [scans, total] = await queryBuilder.getManyAndCount();

    return {
      total,
      page,
      limit,
      data: scans,
    };
  }

  async getAllAssets(): Promise<
    {
      assetId: number;
      assetName: string;
      assetType: AssetType;
      configuration_id: string;
    }[]
  > {
    const rawAssets = await this.vulnerabilityRepository
      .createQueryBuilder('scan')
      .select('DISTINCT scan.asset_id', 'asset_id')
      .addSelect('scan.asset_name', 'asset_name')
      .addSelect('scan.asset_type', 'asset_type')
      .addSelect('scan.configuration_id', 'configuration_id')
      .where('scan.asset_id IS NOT NULL')
      .andWhere('scan.asset_name IS NOT NULL')
      .andWhere('scan.asset_type IS NOT NULL')
      .orderBy('scan.asset_id', 'ASC')
      .getRawMany();

    return rawAssets;
  }

  // Vulnearability Scan - create scan, update scan status
  async createScan(
    scanType: ScanTriggerType,
    assetId?: number,
    userId?: number,
    schedulerScanId?: number
  ): Promise<VulnerabilityScan> {
    try {
      const scan = await this.scanRepository.save({
        status: ScanStatus.PENDING,
        scanType,
        assetId: assetId ?? null,
        userId: userId ?? null,
        schedulerScanId: schedulerScanId ?? null,
      });

      this.logger.info({ scanId: scan.id }, 'Created new VulnerabilityScan');
      return scan;
    } catch (error) {
      this.logger.error({ error }, 'Error creating new VulnerabilityScan');
      throw new Error('Failed to create scan');
    }
  }

  async updateScanStatus(
    scanId: string,
    newStatus: ScanStatus,
    errorMsg?: string
  ): Promise<VulnerabilityScan> {
    this.logger.info({ scanId, newStatus }, 'Attempting to update scan status');

    const scan = await this.scanRepository.findOne({
      where: { uuid: scanId },
    });

    if (!scan) {
      this.logger.error({ scanId }, 'Scan not found for status update');
      throw new Error(`Scan with id=${scanId} not found`);
    }
    scan.status = newStatus;

    if (newStatus === ScanStatus.FAILED && errorMsg) {
      this.logger.error({ scanId, errorMsg }, 'Scan failed');
    }

    const updatedScan = await this.scanRepository.save(scan);
    this.logger.info(
      { scanId: updatedScan.id, status: updatedScan.status },
      'Scan status updated successfully'
    );
    return updatedScan;
  }

  async findUniqueVulnerabilities(
    filters: GetVulnerabilityFilterDto,
    pagination: PaginationRequestDto
  ): Promise<[UniqueVulnerabilityResponse[], number]> {
    try {
      const query = this.vulnerabilityRepository
        .createQueryBuilder('vuln')
        .select([
          'vuln.templateId as templateId',
          'vuln.infoName as name',
          'vuln.infoSeverity as severity',
          'vuln.infoDescription as description',
          'vuln.infoRemediation as remediation',
          'vuln.infoImpact as impact',
          'COUNT(DISTINCT vuln.assetId) as "totalAssets"',
        ])
        .groupBy('vuln.templateId')
        .addGroupBy('vuln.infoName')
        .addGroupBy('vuln.assetName')
        .addGroupBy('vuln.assetType')
        .addGroupBy('vuln.infoSeverity')
        .addGroupBy('vuln.infoDescription')
        .addGroupBy('vuln.infoRemediation')
        .addGroupBy('vuln.infoImpact');

      // Apply dynamic filters
      Object.entries(filters).forEach(([key, value]) => {
        if (
          [
            'page',
            'limit',
            'sort_by',
            'order_by',
            'timestampStart',
            'timestampEnd',
          ].includes(key)
        ) {
          return;
        }

        if (Array.isArray(value)) {
          query.andWhere(`vuln.${key} IN (:...${key}Values)`, {
            [`${key}Values`]: value,
          });
        } else if (value !== null && value !== undefined) {
          query.andWhere(`vuln.${key} = :${key}Value`, {
            [`${key}Value`]: value,
          });
        }
      });

      // Add pagination
      const page = pagination.page || 1;
      const limit = pagination.limit || 10;

      query.offset((page - 1) * limit).limit(limit);

      // Get total count with the same filters
      const totalQuery = this.vulnerabilityRepository
        .createQueryBuilder('vuln')
        .select('COUNT(DISTINCT vuln.infoName)', 'count');

      const [results, totalCount] = await Promise.all([
        query.getRawMany(),
        totalQuery.getRawOne(),
      ]);

      return [results, parseInt(totalCount.count)];
    } catch (error) {
      this.logger.error({ error }, 'Er  ror finding unique vulnerabilities');
      throw error;
    }
  }

  async initiateRetest(vulnerabilityId: string, userId: string): Promise<void> {
    const vulnerability = await this.vulnerabilityRepository.findOne({
      where: { uuid: vulnerabilityId },
    });

    if (!vulnerability) {
      throw new NotFoundException(
        `Vulnerability with ID "${vulnerabilityId}" not found`
      );
    }

    // Get configuration based on the vulnerability profile
    const configuration = await this.configurationService.findOneById(
      vulnerability.configurationId
    );
    if (!configuration) {
      throw new NotFoundException('Configuration not found');
    }

    const eventData: VulnerabilityRescanEventData = {
      vulnerabilityId: vulnerability.id,
      assetName: vulnerability.assetName,
      templateId: vulnerability.templatePath,
      profile: vulnerability.profile,
      configJson: configuration.config,
      originalVulnerabilityInfo: vulnerability.allPayload,
    };

    const message: CloudEvent<VulnerabilityRescanEventData> = {
      id: UUID.v4(),
      source: 'vulnerability-service',
      type: 'vulnerability.rescan',
      time: new Date(),
      specversion: '1.0',
      data: eventData,
    };

    try {
      await this.messagePubSubService.sendMessage(
        'vulnerability.rescan',
        message
      );
      this.logger.info(
        { vulnerabilityId, userId },
        'Vulnerability retest message sent successfully'
      );
    } catch (error) {
      this.logger.error(
        { error, vulnerabilityId, userId },
        'Failed to send vulnerability retest message'
      );
      throw new Error('Failed to initiate vulnerability retest');
    }
  }

  getVulnerabilityById(id: number) {
    return this.vulnerabilityRepository.findOne({
      where: { id },
    });
  }
}
