import {
  MigrationInterface,
  QueryRunner,
  Table,
  TableColumn,
  TableForeignKey,
} from 'typeorm';

export class VulnerabilityMigration1747586738360 implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    // Drop the existing table if it exists
    await queryRunner.query(`DROP TABLE IF EXISTS "asset_allowlist"`);
    // Drop the existing table if it exists
    await queryRunner.query(`DROP TABLE IF EXISTS "tech_detections"`);

    // Create the asset_type_enum if it doesn't exist
    await queryRunner.query(`
      DO $$ BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'asset_type_enum') THEN
          CREATE TYPE asset_type_enum AS ENUM (
            'webapp',
            'ip',
            'domain',
            'subdomain',
            'service',
            'webapp_api',
            'unknown'
          );
        END IF;
      END $$;
    `);

    // Create the vulnerability_profiles_enum if it doesn't exist
    await queryRunner.query(`
      DO $$ BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vulnerability_profiles_enum') THEN
          CREATE TYPE vulnerability_profiles_enum AS ENUM (
            'cve',
            'default-logins',
            'dns',
            'misconfig',
            'ssl',
            'owasp-top-10',
            'tech-detect',
            'dast',
            'file'
          );
        END IF;
      END $$;
    `);

    // Create the new table based on the entity
    await queryRunner.createTable(
      new Table({
        name: 'asset_allowlist',
        columns: [
          {
            name: 'id',
            type: 'serial',
            isPrimary: true,
          },
          {
            name: 'uuid',
            type: 'uuid',
            isGenerated: true,
            generationStrategy: 'uuid',
          },
          {
            name: 'asset_type',
            type: 'enum',
            enumName: 'asset_type_enum',
          },
          {
            name: 'asset_id',
            type: 'integer',
          },
          {
            name: 'vulnerability_profiles',
            type: 'enum',
            enumName: 'vulnerability_profiles_enum',
            isArray: true,
            default: "'{}'",
          },
          {
            name: 'description',
            type: 'text',
            isNullable: true,
          },
          {
            name: 'active',
            type: 'boolean',
            default: true,
          },
          {
            name: 'created_at',
            type: 'timestamp',
            default: 'now()',
          },
          {
            name: 'updated_at',
            type: 'timestamp',
            default: 'now()',
          },
        ],
        foreignKeys: [
          {
            columnNames: ['asset_id'],
            referencedTableName: 'asset',
            referencedColumnNames: ['id'],
            onDelete: 'CASCADE',
          },
        ],
      })
    );

    // Update `vulnerability` table: Change `assetId` type to `int` and add relation with `asset` table
    await queryRunner.changeColumn(
      'vulnerabilities_v2',
      'asset_id',
      new TableColumn({
        name: 'asset_id',
        type: 'int',
        isNullable: false,
      })
    );

    await queryRunner.createForeignKey(
      'vulnerabilities_v2',
      new TableForeignKey({
        columnNames: ['asset_id'],
        referencedTableName: 'asset',
        referencedColumnNames: ['id'],
        onDelete: 'CASCADE',
      })
    );

    // Update `vulnerability_scan` table: Change `assetId` type to `int` and add relation with `asset` table
    await queryRunner.changeColumn(
      'vulnerability_v2_scans',
      'asset_id',
      new TableColumn({
        name: 'asset_id',
        type: 'int',
        isNullable: true,
      })
    );

    await queryRunner.createForeignKey(
      'vulnerability_v2_scans',
      new TableForeignKey({
        columnNames: ['asset_id'],
        referencedTableName: 'asset',
        referencedColumnNames: ['id'],
        onDelete: 'CASCADE',
      })
    );

    // Create the new table based on the entity
    await queryRunner.createTable(
      new Table({
        name: 'tech_detections',
        columns: [
          {
            name: 'id',
            type: 'serial',
            isPrimary: true,
          },
          {
            name: 'uuid',
            type: 'uuid',
            isGenerated: true,
            generationStrategy: 'uuid',
            isUnique: true,
          },
          {
            name: 'template_id',
            type: 'varchar',
          },
          {
            name: 'template_path',
            type: 'text',
            isNullable: true,
          },
          {
            name: 'template_encoded',
            type: 'text',
            isNullable: true,
          },
          {
            name: 'info_name',
            type: 'varchar',
            isNullable: true,
          },
          {
            name: 'info_severity',
            type: 'enum',
            enumName: 'severity_enum',
            enum: ['info', 'low', 'medium', 'high', 'critical'], // Replace with actual Severity enum values
            isNullable: true,
          },
          {
            name: 'info_description',
            type: 'text',
            isNullable: true,
          },
          {
            name: 'info_impact',
            type: 'text',
            isNullable: true,
          },
          {
            name: 'info_remediation',
            type: 'text',
            isNullable: true,
          },
          {
            name: 'type',
            type: 'varchar',
            isNullable: true,
          },
          {
            name: 'host',
            type: 'varchar',
            isNullable: true,
          },
          {
            name: 'port',
            type: 'varchar',
            isNullable: true,
          },
          {
            name: 'scheme',
            type: 'varchar',
            isNullable: true,
          },
          {
            name: 'url',
            type: 'varchar',
            isNullable: true,
          },
          {
            name: 'matched_at',
            type: 'varchar',
            isNullable: true,
          },
          {
            name: 'request',
            type: 'text',
            isNullable: true,
          },
          {
            name: 'response',
            type: 'text',
            isNullable: true,
          },
          {
            name: 'ip',
            type: 'varchar',
            isNullable: true,
          },
          {
            name: 'timestamp',
            type: 'timestamptz',
            isNullable: true,
          },
          {
            name: 'curl_command',
            type: 'text',
            isNullable: true,
          },
          {
            name: 'matcher_status',
            type: 'boolean',
            isNullable: true,
          },
          {
            name: 'all_payload',
            type: 'jsonb',
            isNullable: true,
          },
          {
            name: 'created_at',
            type: 'timestamp',
            default: 'now()',
          },
          {
            name: 'updated_at',
            type: 'timestamp',
            default: 'now()',
          },
          {
            name: 'configuration_id',
            type: 'integer',
            isNullable: true,
          },
          {
            name: 'asset_id',
            type: 'integer',
          },
          {
            name: 'asset_name',
            type: 'varchar',
          },
          {
            name: 'asset_type',
            type: 'enum',
            enumName: 'asset_type_enum',
          },
          {
            name: 'scan_id',
            type: 'integer',
            isNullable: true,
          },
        ],
        foreignKeys: [
          {
            columnNames: ['configuration_id'],
            referencedTableName: 'configurations',
            referencedColumnNames: ['id'],
            onDelete: 'SET NULL',
          },
          {
            columnNames: ['asset_id'],
            referencedTableName: 'asset',
            referencedColumnNames: ['id'],
            onDelete: 'CASCADE',
          },
          {
            columnNames: ['scan_id'],
            referencedTableName: 'vulnerability_v2_scans',
            referencedColumnNames: ['id'],
            onDelete: 'CASCADE',
          },
        ],
      })
    );

    // Create enums if they do not exist
    await queryRunner.query(`
      DO $$ BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'incident_status_enum') THEN
          CREATE TYPE "incident_status_enum" AS ENUM ('open', 'in-progress', 'closed');
        END IF;
      END $$;
    `);

    await queryRunner.query(`
      DO $$ BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'incident_type_enum') THEN
          CREATE TYPE "incident_type_enum" AS ENUM ('secret', 'vulnerability', 'vulnerability_vm');
        END IF;
      END $$;
    `);

    await queryRunner.query(`
      DO $$ BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'incident_closed_by_enum') THEN
          CREATE TYPE "incident_closed_by_enum" AS ENUM ('user', 'program');
        END IF;
      END $$;
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    // Revert changes in `vulnerability` table
    const vulnerabilityTable = await queryRunner.getTable('vulnerabilities_v2');
    const vulnerabilityForeignKey = vulnerabilityTable?.foreignKeys || [];
    const assetForeignKey = vulnerabilityForeignKey.find((fk) =>
      fk.columnNames.includes('asset_id')
    );
    if (assetForeignKey) {
      await queryRunner.dropForeignKey('vulnerabilities_v2', assetForeignKey);
    }

    await queryRunner.changeColumn(
      'vulnerabilities_v2',
      'asset_id',
      new TableColumn({
        name: 'asset_id',
        type: 'varchar',
        isNullable: false,
      })
    );

    // Revert changes in `vulnerability_scan` table
    const scanTable = await queryRunner.getTable('vulnerability_v2_scans');
    const scanForeignKey = scanTable?.foreignKeys || [];
    const scanAssetForeignKey = scanForeignKey.find((fk) =>
      fk.columnNames.includes('asset_id')
    );
    if (scanAssetForeignKey) {
      await queryRunner.dropForeignKey(
        'vulnerability_v2_scans',
        scanAssetForeignKey
      );
    }

    await queryRunner.changeColumn(
      'vulnerability_v2_scans',
      'asset_id',
      new TableColumn({
        name: 'asset_id',
        type: 'varchar',
        isNullable: true,
      })
    );

    // Drop the existing table if it exists
    await queryRunner.query(`DROP TABLE IF EXISTS "asset_allowlist"`);
    // Drop the existing table if it exists
    await queryRunner.query(`DROP TABLE IF EXISTS "tech_detections"`);
  }
}
