from sqlalchemy.future import select
from sqlalchemy import update, insert, or_
from sqlalchemy.ext.asyncio import AsyncSession
from datetime import datetime
from typing import Optional, List
from app.modules.vulnerability.models.vulnerability_model import Vulnerability
from app.modules.incidents.models.incident_model import Incidents, IncidentStatusEnum, IncidentClosedBy
from app.modules.incidents.models.activity_model import Activity, Action

# import utils
from app.utils.whitelist.check_vulnerability_whitelisted import check_vulnerabilities_whitelisted
from app.utils.whitelist.update_pr_status import update_pr_status

from app.core.logger import logger
from sqlalchemy import select, update, or_, and_
from sqlalchemy.ext.asyncio import AsyncSession
from datetime import datetime
from app.modules.whitelist.model.whitelist_model import Whitelist

async def add_vulnerability_str(
    db: AsyncSession,
    whitelist: Whitelist
) -> int:
    """
    Whitelist vulnerabilities according to a Whitelist object.

    1. Collect all filter conditions in a list.
    2. Use the same conditions for both the UPDATE and SELECT statements.
    3. Close incidents and log activity for updated vulnerabilities.
    4. Update PR status if all vulnerabilities in the PR are whitelisted.
    """
    name = whitelist.name
    repos = whitelist.repos or []
    vcs = whitelist.vcs or []
    is_global = whitelist.global_
    active = whitelist.active
    wl_id = whitelist.id
    user_id = whitelist.created_by

    logger.info(f"Starting vulnerability whitelisting for whitelist id={wl_id}")
    conditions = []
    if name:
        conditions.append(or_(
            Vulnerability.vulnerability_id == name,
            Vulnerability.cve_id == name
        ))

    if not is_global:
        if repos:
            conditions.append(Vulnerability.repository_id.in_(repos))
        if vcs:
            conditions.append(Vulnerability.vc_id.in_(vcs))

    update_stmt = (
        update(Vulnerability)
        .where(and_(*conditions)) if conditions else update(Vulnerability)
    )
    update_stmt = update_stmt.values(whitelisted=active, whitelist_id=wl_id)
    await db.execute(update_stmt)
    logger.info("Executed UPDATE statement to set vulnerabilities as whitelisted.")

    filter_for_select = []
    if conditions:
        filter_for_select.append(and_(*conditions))
    filter_for_select.append(Vulnerability.whitelisted == active)
    filter_for_select.append(Vulnerability.whitelist_id == wl_id)

    query_for_ids = select(Vulnerability.id).where(and_(*filter_for_select))

    v_ids = await db.scalars(query_for_ids)
    vulnerability_ids_list = v_ids.all()
    logger.info(f"Whitelisted vulnerabilities: {vulnerability_ids_list}")

    if not vulnerability_ids_list:
        logger.warning("No vulnerabilities matched the whitelist criteria.")
        await db.commit()
        return 0

    # Close open incidents
    incident_stmt = (
        update(Incidents)
        .where(
            Incidents.vulnerability_id.in_(vulnerability_ids_list),
            Incidents.closed_by.is_(None),
        )
        .values(
            status=IncidentStatusEnum.CLOSED,
            closed_by=IncidentClosedBy.PROGRAM,
        )
    )
    await db.execute(incident_stmt)
    logger.info(f"Closed incidents for vulnerabilities: {vulnerability_ids_list}")

    incidents = await db.scalars(
        select(Incidents).where(Incidents.vulnerability_id.in_(vulnerability_ids_list))
    )
    for incident in incidents.all():
        await db.execute(
            insert(Activity).values(
                action=Action.INCIDENT_CLOSED,
                old_value=str(IncidentStatusEnum.OPEN),
                new_value=str(IncidentStatusEnum.CLOSED),
                incident_id=incident.id,
                user_id=user_id,
                created_at=datetime.utcnow(),
            )
        )
        logger.debug(f"Logged activity for closed incident={incident.id}")

    await db.commit()
    logger.info("Committed changes to the database after closing incidents.")

    # Update PR statuses if all vulnerabilities in the PR are whitelisted
    vuln_prs = await db.scalars(
        select(Vulnerability.pr_scan_id)
        .where(Vulnerability.id.in_(vulnerability_ids_list))
        .distinct()
    )
    for pr_scan_id in vuln_prs.all():
        if pr_scan_id:
            all_whitelisted = await check_vulnerabilities_whitelisted(db, pr_scan_id)
            if all_whitelisted:
                await update_pr_status(db, pr_scan_id, unblock=True)
                logger.info(f"Updated PR scan {pr_scan_id} status to unblocked.")

    logger.info(f"Finished vulnerability whitelisting process={ len(vulnerability_ids_list)}")
    return len(vulnerability_ids_list)
